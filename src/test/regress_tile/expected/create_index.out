--
-- CREATE_INDEX
-- Create ancillary data structures (i.e. indices)
--
--
-- BTREE
--
CREATE INDEX onek_unique1 ON onek USING btree(unique1 int4_ops);
CREATE INDEX IF NOT EXISTS onek_unique1 ON onek USING btree(unique1 int4_ops);
NOTICE:  relation "onek_unique1" already exists, skipping
CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_ops);
ERROR:  syntax error at or near "ON"
LINE 1: CREATE INDEX IF NOT EXISTS ON onek USING btree(unique1 int4_...
                                   ^
CREATE INDEX onek_unique2 ON onek USING btree(unique2 int4_ops);
CREATE INDEX onek_hundred ON onek USING btree(hundred int4_ops);
CREATE INDEX onek_stringu1 ON onek USING btree(stringu1 name_ops);
CREATE INDEX tenk1_unique1 ON tenk1 USING btree(unique1 int4_ops);
CREATE INDEX tenk1_unique2 ON tenk1 USING btree(unique2 int4_ops);
CREATE INDEX tenk1_hundred ON tenk1 USING btree(hundred int4_ops);
CREATE INDEX tenk1_thous_tenthous ON tenk1 (thousand, tenthous);
CREATE INDEX tenk2_unique1 ON tenk2 USING btree(unique1 int4_ops);
CREATE INDEX tenk2_unique2 ON tenk2 USING btree(unique2 int4_ops);
CREATE INDEX tenk2_hundred ON tenk2 USING btree(hundred int4_ops);
CREATE INDEX rix ON road USING btree (name text_ops);
CREATE INDEX iix ON ihighway USING btree (name text_ops);
CREATE INDEX six ON shighway USING btree (name text_ops);
-- test comments
COMMENT ON INDEX six_wrong IS 'bad index';
ERROR:  relation "six_wrong" does not exist
COMMENT ON INDEX six IS 'good index';
COMMENT ON INDEX six IS NULL;
--
-- BTREE ascending/descending cases
--
-- we load int4/text from pure descending data (each key is a new
-- low key) and name/f8 from pure ascending data (each key is a new
-- high key).  we had a bug where new low keys would sometimes be
-- "lost".
--
CREATE INDEX bt_i4_index ON bt_i4_heap USING btree (seqno int4_ops);
CREATE INDEX bt_name_index ON bt_name_heap USING btree (seqno name_ops);
CREATE INDEX bt_txt_index ON bt_txt_heap USING btree (seqno text_ops);
CREATE INDEX bt_f8_index ON bt_f8_heap USING btree (seqno float8_ops);
--
-- BTREE partial indices
--
CREATE INDEX onek2_u1_prtl ON onek2 USING btree(unique1 int4_ops)
	where unique1 < 20 or unique1 > 980;
CREATE INDEX onek2_u2_prtl ON onek2 USING btree(unique2 int4_ops)
	where stringu1 < 'B';
CREATE INDEX onek2_stu1_prtl ON onek2 USING btree(stringu1 name_ops)
	where onek2.stringu1 >= 'J' and onek2.stringu1 < 'K';
--
-- GiST (rtree-equivalent opclasses only)
--
-- CREATE INDEX grect2ind ON fast_emp4000 USING gist (home_base);
--
-- CREATE INDEX gpolygonind ON polygon_tbl USING gist (f1);
--
-- CREATE INDEX gcircleind ON circle_tbl USING gist (f1);
INSERT INTO POINT_TBL(f1) VALUES (NULL);
-- CREATE INDEX gpointind ON point_tbl USING gist (f1);
CREATE TEMP TABLE gpolygon_tbl AS
    SELECT polygon(home_base) AS f1 FROM slow_emp4000;
INSERT INTO gpolygon_tbl VALUES ( '(1000,0,0,1000)' );
INSERT INTO gpolygon_tbl VALUES ( '(0,1000,1000,1000)' );
CREATE TEMP TABLE gcircle_tbl AS
    SELECT circle(home_base) AS f1 FROM slow_emp4000;
-- CREATE INDEX ggpolygonind ON gpolygon_tbl USING gist (f1);
--
-- CREATE INDEX ggcircleind ON gcircle_tbl USING gist (f1);
--
-- Test GiST indexes
--
-- get non-indexed results for comparison purposes
SET enable_seqscan = ON;
SET enable_indexscan = OFF;
SET enable_bitmapscan = OFF;
SELECT * FROM fast_emp4000
    WHERE home_base @ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
       home_base       
-----------------------
 (337,455),(240,359)
 (1444,403),(1346,344)
(2 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
 count 
-------
     2
(1 row)

SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
 count 
-------
   278
(1 row)

SELECT * FROM polygon_tbl WHERE f1 ~ '((1,1),(2,2),(2,1))'::polygon
    ORDER BY (poly_center(f1))[0];
         f1          
---------------------
 ((2,0),(2,4),(0,0))
(1 row)

SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)
    ORDER BY area(f1);
      f1       
---------------
 <(1,2),3>
 <(1,3),5>
 <(1,2),100>
 <(100,1),115>
(4 rows)

SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
 count 
-------
     2
(1 row)

SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
 count 
-------
     2
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
 count 
-------
     5
(1 row)

SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
 count 
-------
     1
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
 count 
-------
     3
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 <^ '(0.0, 0.0)';
 count 
-------
     1
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 >^ '(0.0, 0.0)';
 count 
-------
     4
(1 row)

SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
 count 
-------
     1
(1 row)

SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (1e+300,Infinity)
 (NaN,NaN)
 
(10 rows)

SELECT * FROM point_tbl WHERE f1 IS NULL;
 f1 
----
 
(1 row)

SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (1e-300,-1e-300)
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (1e+300,Infinity)
 (NaN,NaN)
(9 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
        f1        
------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
(5 rows)

SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                       f1                        
-------------------------------------------------
 ((240,359),(240,455),(337,455),(337,359))
 ((662,163),(662,187),(759,187),(759,163))
 ((1000,0),(0,1000))
 ((0,1000),(1000,1000))
 ((1346,344),(1346,403),(1444,403),(1444,344))
 ((278,1409),(278,1457),(369,1457),(369,1409))
 ((907,1156),(907,1201),(948,1201),(948,1156))
 ((1517,971),(1517,1043),(1594,1043),(1594,971))
 ((175,1820),(175,1850),(259,1850),(259,1820))
 ((2424,81),(2424,160),(2424,160),(2424,81))
(10 rows)

SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
 circle_center  | radius 
----------------+--------
 (288.5,407)    |     68
 (710.5,175)    |     50
 (323.5,1433)   |     51
 (927.5,1178.5) |     30
 (1395,373.5)   |     57
 (1555.5,1007)  |     53
 (217,1835)     |     45
 (489,2421.5)   |     22
 (2424,120.5)   |     40
 (751.5,2655)   |     20
(10 rows)

-- Now check the results from plain indexscan
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
EXPLAIN (COSTS OFF)
SELECT * FROM fast_emp4000
    WHERE home_base @ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
                         QUERY PLAN                         
------------------------------------------------------------
 Sort
   Sort Key: ((home_base[0])[0])
   ->  Seq Scan on fast_emp4000
         Filter: (home_base @ '(2000,1000),(200,200)'::box)
(4 rows)

SELECT * FROM fast_emp4000
    WHERE home_base @ '(200,200),(2000,1000)'::box
    ORDER BY (home_base[0])[0];
       home_base       
-----------------------
 (337,455),(240,359)
 (1444,403),(1346,344)
(2 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
                       QUERY PLAN                        
---------------------------------------------------------
 Aggregate
   ->  Seq Scan on fast_emp4000
         Filter: (home_base && '(1000,1000),(0,0)'::box)
(3 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base && '(1000,1000,0,0)'::box;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
             QUERY PLAN              
-------------------------------------
 Aggregate
   ->  Seq Scan on fast_emp4000
         Filter: (home_base IS NULL)
(3 rows)

SELECT count(*) FROM fast_emp4000 WHERE home_base IS NULL;
 count 
-------
   278
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM polygon_tbl WHERE f1 ~ '((1,1),(2,2),(2,1))'::polygon
    ORDER BY (poly_center(f1))[0];
                      QUERY PLAN                       
-------------------------------------------------------
 Sort
   Sort Key: ((poly_center(f1))[0])
   ->  Seq Scan on polygon_tbl
         Filter: (f1 ~ '((1,1),(2,2),(2,1))'::polygon)
(4 rows)

SELECT * FROM polygon_tbl WHERE f1 ~ '((1,1),(2,2),(2,1))'::polygon
    ORDER BY (poly_center(f1))[0];
         f1          
---------------------
 ((2,0),(2,4),(0,0))
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)
    ORDER BY area(f1);
                  QUERY PLAN                  
----------------------------------------------
 Sort
   Sort Key: (area(f1))
   ->  Seq Scan on circle_tbl
         Filter: (f1 && '<(1,-2),1>'::circle)
(4 rows)

SELECT * FROM circle_tbl WHERE f1 && circle(point(1,-2), 1)
    ORDER BY area(f1);
      f1       
---------------
 <(1,2),3>
 <(1,3),5>
 <(1,2),100>
 <(100,1),115>
(4 rows)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
                       QUERY PLAN                       
--------------------------------------------------------
 Aggregate
   ->  Seq Scan on gpolygon_tbl
         Filter: (f1 && '((1000,1000),(0,0))'::polygon)
(3 rows)

SELECT count(*) FROM gpolygon_tbl WHERE f1 && '(1000,1000,0,0)'::polygon;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
                    QUERY PLAN                     
---------------------------------------------------
 Aggregate
   ->  Seq Scan on gcircle_tbl
         Filter: (f1 && '<(500,500),500>'::circle)
(3 rows)

SELECT count(*) FROM gcircle_tbl WHERE f1 && '<(500,500),500>'::circle;
 count 
-------
     2
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Seq Scan on point_tbl
         Filter: (f1 <@ '(100,100),(0,0)'::box)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ box '(0,0,100,100)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Seq Scan on point_tbl
         Filter: ('(100,100),(0,0)'::box @> f1)
(3 rows)

SELECT count(*) FROM point_tbl WHERE box '(0,0,100,100)' @> f1;
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
                                     QUERY PLAN                                     
------------------------------------------------------------------------------------
 Aggregate
   ->  Seq Scan on point_tbl
         Filter: (f1 <@ '((0,0),(0,100),(100,100),(50,50),(100,0),(0,0))'::polygon)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ polygon '(0,0),(0,100),(100,100),(50,50),(100,0),(0,0)';
 count 
-------
     5
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
                   QUERY PLAN                   
------------------------------------------------
 Aggregate
   ->  Seq Scan on point_tbl
         Filter: (f1 <@ '<(50,50),50>'::circle)
(3 rows)

SELECT count(*) FROM point_tbl WHERE f1 <@ circle '<(50,50),50>';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
               QUERY PLAN               
----------------------------------------
 Aggregate
   ->  Seq Scan on point_tbl p
         Filter: (f1 << '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 << '(0.0, 0.0)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
               QUERY PLAN               
----------------------------------------
 Aggregate
   ->  Seq Scan on point_tbl p
         Filter: (f1 >> '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 >> '(0.0, 0.0)';
 count 
-------
     3
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 <^ '(0.0, 0.0)';
               QUERY PLAN               
----------------------------------------
 Aggregate
   ->  Seq Scan on point_tbl p
         Filter: (f1 <^ '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 <^ '(0.0, 0.0)';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 >^ '(0.0, 0.0)';
               QUERY PLAN               
----------------------------------------
 Aggregate
   ->  Seq Scan on point_tbl p
         Filter: (f1 >^ '(0,0)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 >^ '(0.0, 0.0)';
 count 
-------
     4
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
                QUERY PLAN                 
-------------------------------------------
 Aggregate
   ->  Seq Scan on point_tbl p
         Filter: (f1 ~= '(-5,-12)'::point)
(3 rows)

SELECT count(*) FROM point_tbl p WHERE p.f1 ~= '(-5, -12)';
 count 
-------
     1
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
              QUERY PLAN               
---------------------------------------
 Sort
   Sort Key: ((f1 <-> '(0,1)'::point))
   ->  Seq Scan on point_tbl
(3 rows)

SELECT * FROM point_tbl ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (1e+300,Infinity)
 (NaN,NaN)
 
(10 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 IS NULL;
       QUERY PLAN       
------------------------
 Seq Scan on point_tbl
   Filter: (f1 IS NULL)
(2 rows)

SELECT * FROM point_tbl WHERE f1 IS NULL;
 f1 
----
 
(1 row)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
              QUERY PLAN               
---------------------------------------
 Sort
   Sort Key: ((f1 <-> '(0,1)'::point))
   ->  Seq Scan on point_tbl
         Filter: (f1 IS NOT NULL)
(4 rows)

SELECT * FROM point_tbl WHERE f1 IS NOT NULL ORDER BY f1 <-> '0,1';
        f1         
-------------------
 (1e-300,-1e-300)
 (0,0)
 (-3,4)
 (-10,0)
 (10,10)
 (-5,-12)
 (5.1,34.5)
 (1e+300,Infinity)
 (NaN,NaN)
(9 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
                    QUERY PLAN                    
--------------------------------------------------
 Sort
   Sort Key: ((f1 <-> '(0,1)'::point))
   ->  Seq Scan on point_tbl
         Filter: (f1 <@ '(10,10),(-10,-10)'::box)
(4 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
        f1        
------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
(5 rows)

EXPLAIN (COSTS OFF)
SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                 QUERY PLAN                  
---------------------------------------------
 Limit
   ->  Sort
         Sort Key: ((f1 <-> '(0,0)'::point))
         ->  Seq Scan on gpolygon_tbl
(4 rows)

SELECT * FROM gpolygon_tbl ORDER BY f1 <-> '(0,0)'::point LIMIT 10;
                       f1                        
-------------------------------------------------
 ((240,359),(240,455),(337,455),(337,359))
 ((662,163),(662,187),(759,187),(759,163))
 ((1000,0),(0,1000))
 ((0,1000),(1000,1000))
 ((1346,344),(1346,403),(1444,403),(1444,344))
 ((278,1409),(278,1457),(369,1457),(369,1409))
 ((907,1156),(907,1201),(948,1201),(948,1156))
 ((1517,971),(1517,1043),(1594,1043),(1594,971))
 ((175,1820),(175,1850),(259,1850),(259,1820))
 ((2424,81),(2424,160),(2424,160),(2424,81))
(10 rows)

EXPLAIN (COSTS OFF)
SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
                   QUERY PLAN                    
-------------------------------------------------
 Limit
   ->  Sort
         Sort Key: ((f1 <-> '(200,300)'::point))
         ->  Seq Scan on gcircle_tbl
(4 rows)

SELECT circle_center(f1), round(radius(f1)) as radius FROM gcircle_tbl ORDER BY f1 <-> '(200,300)'::point LIMIT 10;
 circle_center  | radius 
----------------+--------
 (288.5,407)    |     68
 (710.5,175)    |     50
 (323.5,1433)   |     51
 (927.5,1178.5) |     30
 (1395,373.5)   |     57
 (1555.5,1007)  |     53
 (217,1835)     |     45
 (489,2421.5)   |     22
 (2424,120.5)   |     40
 (751.5,2655)   |     20
(10 rows)

-- Now check the results from bitmap indexscan
SET enable_seqscan = OFF;
SET enable_indexscan = OFF;
SET enable_bitmapscan = ON;
EXPLAIN (COSTS OFF)
SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
                    QUERY PLAN                    
--------------------------------------------------
 Sort
   Sort Key: ((f1 <-> '(0,1)'::point))
   ->  Seq Scan on point_tbl
         Filter: (f1 <@ '(10,10),(-10,-10)'::box)
(4 rows)

SELECT * FROM point_tbl WHERE f1 <@ '(-10,-10),(10,10)':: box ORDER BY f1 <-> '0,1';
        f1        
------------------
 (0,0)
 (1e-300,-1e-300)
 (-3,4)
 (-10,0)
 (10,10)
(5 rows)

RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
--
-- Test functional index
--
CREATE TABLE func_index_heap (f1 text, f2 text);
CREATE UNIQUE INDEX func_index_index on func_index_heap (textcat(f1,f2));
INSERT INTO func_index_heap VALUES('ABC','DEF');
INSERT INTO func_index_heap VALUES('AB','CDEFG');
INSERT INTO func_index_heap VALUES('QWE','RTY');
-- this should fail because of unique index:
INSERT INTO func_index_heap VALUES('ABCD', 'EF');
ERROR:  duplicate key value violates unique constraint "func_index_index"
DETAIL:  Key (textcat(f1, f2))=(ABCDEF) already exists.
-- but this shouldn't:
INSERT INTO func_index_heap VALUES('QWERTY');
-- while we're here, see that the metadata looks sane
\d func_index_heap
         Table "public.func_index_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "func_index_index" UNIQUE, btree (textcat(f1, f2))

\d func_index_index
     Index "public.func_index_index"
 Column  | Type | Key? |   Definition    
---------+------+------+-----------------
 textcat | text | yes  | textcat(f1, f2)
unique, btree, for table "public.func_index_heap"

--
-- Same test, expressional index
--
DROP TABLE func_index_heap;
CREATE TABLE func_index_heap (f1 text, f2 text);
CREATE UNIQUE INDEX func_index_index on func_index_heap ((f1 || f2) text_ops);
INSERT INTO func_index_heap VALUES('ABC','DEF');
INSERT INTO func_index_heap VALUES('AB','CDEFG');
INSERT INTO func_index_heap VALUES('QWE','RTY');
-- this should fail because of unique index:
INSERT INTO func_index_heap VALUES('ABCD', 'EF');
ERROR:  duplicate key value violates unique constraint "func_index_index"
DETAIL:  Key ((f1 || f2))=(ABCDEF) already exists.
-- but this shouldn't:
INSERT INTO func_index_heap VALUES('QWERTY');
-- while we're here, see that the metadata looks sane
\d func_index_heap
         Table "public.func_index_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "func_index_index" UNIQUE, btree ((f1 || f2))

\d func_index_index
  Index "public.func_index_index"
 Column | Type | Key? | Definition 
--------+------+------+------------
 expr   | text | yes  | (f1 || f2)
unique, btree, for table "public.func_index_heap"

-- this should fail because of unsafe column type (anonymous record)
create index on func_index_heap ((f1 || f2), (row(f1, f2)));
ERROR:  column "row" has pseudo-type record
--
-- Test unique index with included columns
--
CREATE TABLE covering_index_heap (f1 int, f2 int, f3 text);
CREATE UNIQUE INDEX covering_index_index on covering_index_heap (f1,f2) INCLUDE(f3);
INSERT INTO covering_index_heap VALUES(1,1,'AAA');
INSERT INTO covering_index_heap VALUES(1,2,'AAA');
-- this should fail because of unique index on f1,f2:
INSERT INTO covering_index_heap VALUES(1,2,'BBB');
ERROR:  duplicate key value violates unique constraint "covering_index_index"
DETAIL:  Key (f1, f2)=(1, 2) already exists.
-- and this shouldn't:
INSERT INTO covering_index_heap VALUES(1,4,'AAA');
-- Try to build index on table that already contains data
CREATE UNIQUE INDEX covering_pkey on covering_index_heap (f1,f2) INCLUDE(f3);
-- Try to use existing covering index as primary key
ALTER TABLE covering_index_heap ADD CONSTRAINT covering_pkey PRIMARY KEY USING INDEX
covering_pkey;
DROP TABLE covering_index_heap;
--
-- Also try building functional, expressional, and partial indexes on
-- tables that already contain data.
--
create unique index hash_f8_index_1 on hash_f8_heap(abs(random));
create unique index hash_f8_index_2 on hash_f8_heap((seqno + 1), random);
create unique index hash_f8_index_3 on hash_f8_heap(random) where seqno > 1000;
--
-- Try some concurrent index builds
--
-- Unfortunately this only tests about half the code paths because there are
-- no concurrent updates happening to the table at the same time.
CREATE TABLE concur_heap (f1 text, f2 text);
-- empty table
CREATE INDEX CONCURRENTLY concur_index1 ON concur_heap(f2,f1);
CREATE INDEX CONCURRENTLY IF NOT EXISTS concur_index1 ON concur_heap(f2,f1);
NOTICE:  relation "concur_index1" already exists, skipping
INSERT INTO concur_heap VALUES  ('a','b');
INSERT INTO concur_heap VALUES  ('b','b');
-- unique index
CREATE UNIQUE INDEX CONCURRENTLY concur_index2 ON concur_heap(f1);
CREATE UNIQUE INDEX CONCURRENTLY IF NOT EXISTS concur_index2 ON concur_heap(f1);
NOTICE:  relation "concur_index2" already exists, skipping
-- check if constraint is set up properly to be enforced
INSERT INTO concur_heap VALUES ('b','x');
ERROR:  duplicate key value violates unique constraint "concur_index2"
DETAIL:  Key (f1)=(b) already exists.
-- check if constraint is enforced properly at build time
CREATE UNIQUE INDEX CONCURRENTLY concur_index3 ON concur_heap(f2);
ERROR:  could not create unique index "concur_index3"
DETAIL:  Key (f2)=(b) is duplicated.
-- test that expression indexes and partial indexes work concurrently
CREATE INDEX CONCURRENTLY concur_index4 on concur_heap(f2) WHERE f1='a';
CREATE INDEX CONCURRENTLY concur_index5 on concur_heap(f2) WHERE f1='x';
-- here we also check that you can default the index name
CREATE INDEX CONCURRENTLY on concur_heap((f2||f1));
-- You can't do a concurrent index build in a transaction
BEGIN;
CREATE INDEX CONCURRENTLY concur_index7 ON concur_heap(f1);
ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- But you can do a regular index build in a transaction
BEGIN;
CREATE INDEX std_index on concur_heap(f2);
COMMIT;
-- Failed builds are left invalid by VACUUM FULL, fixed by REINDEX
VACUUM FULL concur_heap;
REINDEX TABLE concur_heap;
DELETE FROM concur_heap WHERE f1 = 'b';
VACUUM FULL concur_heap;
\d concur_heap
           Table "public.concur_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "concur_index2" UNIQUE, btree (f1)
    "concur_heap_expr_idx" btree ((f2 || f1))
    "concur_index1" btree (f2, f1)
    "concur_index4" btree (f2) WHERE f1 = 'a'::text
    "concur_index5" btree (f2) WHERE f1 = 'x'::text
    "std_index" btree (f2)

REINDEX TABLE concur_heap;
\d concur_heap
           Table "public.concur_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "concur_index2" UNIQUE, btree (f1)
    "concur_heap_expr_idx" btree ((f2 || f1))
    "concur_index1" btree (f2, f1)
    "concur_index4" btree (f2) WHERE f1 = 'a'::text
    "concur_index5" btree (f2) WHERE f1 = 'x'::text
    "std_index" btree (f2)

-- Temporary tables with concurrent builds and on-commit actions
-- CONCURRENTLY used with CREATE INDEX and DROP INDEX is ignored.
-- PRESERVE ROWS, the default.
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT PRESERVE ROWS;
INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
DROP INDEX CONCURRENTLY concur_temp_ind;
DROP TABLE concur_temp;
-- ON COMMIT DROP
BEGIN;
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT DROP;
INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
-- Fails when running in a transaction.
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
ERROR:  CREATE INDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- ON COMMIT DELETE ROWS
CREATE TEMP TABLE concur_temp (f1 int, f2 text)
  ON COMMIT DELETE ROWS;
INSERT INTO concur_temp VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX CONCURRENTLY concur_temp_ind ON concur_temp(f1);
DROP INDEX CONCURRENTLY concur_temp_ind;
DROP TABLE concur_temp;
--
-- Try some concurrent index drops
--
DROP INDEX CONCURRENTLY "concur_index2";				-- works
DROP INDEX CONCURRENTLY IF EXISTS "concur_index2";		-- notice
NOTICE:  index "concur_index2" does not exist, skipping
-- failures
DROP INDEX CONCURRENTLY "concur_index2", "concur_index3";
ERROR:  DROP INDEX CONCURRENTLY does not support dropping multiple objects
BEGIN;
DROP INDEX CONCURRENTLY "concur_index5";
ERROR:  DROP INDEX CONCURRENTLY cannot run inside a transaction block
ROLLBACK;
-- successes
DROP INDEX CONCURRENTLY IF EXISTS "concur_index3";
NOTICE:  index "concur_index3" does not exist, skipping
DROP INDEX CONCURRENTLY "concur_index4";
DROP INDEX CONCURRENTLY "concur_index5";
DROP INDEX CONCURRENTLY "concur_index1";
DROP INDEX CONCURRENTLY "concur_heap_expr_idx";
\d concur_heap
           Table "public.concur_heap"
 Column | Type | Collation | Nullable | Default 
--------+------+-----------+----------+---------
 f1     | text |           |          | 
 f2     | text |           |          | 
Indexes:
    "std_index" btree (f2)

DROP TABLE concur_heap;
--
-- Test ADD CONSTRAINT USING INDEX
--
CREATE TABLE cwi_test( a int , b varchar(10), c char);
-- add some data so that all tests have something to work with.
INSERT INTO cwi_test VALUES(1, 2), (3, 4), (5, 6);
CREATE UNIQUE INDEX cwi_uniq_idx ON cwi_test(a , b);
ALTER TABLE cwi_test ADD primary key USING INDEX cwi_uniq_idx;
\d cwi_test
                     Table "public.cwi_test"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 a      | integer               |           | not null | 
 b      | character varying(10) |           | not null | 
 c      | character(1)          |           |          | 
Indexes:
    "cwi_uniq_idx" PRIMARY KEY, btree (a, b)

\d cwi_uniq_idx
            Index "public.cwi_uniq_idx"
 Column |         Type          | Key? | Definition 
--------+-----------------------+------+------------
 a      | integer               | yes  | a
 b      | character varying(10) | yes  | b
primary key, btree, for table "public.cwi_test"

CREATE UNIQUE INDEX cwi_uniq2_idx ON cwi_test(b , a);
ALTER TABLE cwi_test DROP CONSTRAINT cwi_uniq_idx,
	ADD CONSTRAINT cwi_replaced_pkey PRIMARY KEY
		USING INDEX cwi_uniq2_idx;
NOTICE:  ALTER TABLE / ADD CONSTRAINT USING INDEX will rename index "cwi_uniq2_idx" to "cwi_replaced_pkey"
\d cwi_test
                     Table "public.cwi_test"
 Column |         Type          | Collation | Nullable | Default 
--------+-----------------------+-----------+----------+---------
 a      | integer               |           | not null | 
 b      | character varying(10) |           | not null | 
 c      | character(1)          |           |          | 
Indexes:
    "cwi_replaced_pkey" PRIMARY KEY, btree (b, a)

\d cwi_replaced_pkey
          Index "public.cwi_replaced_pkey"
 Column |         Type          | Key? | Definition 
--------+-----------------------+------+------------
 b      | character varying(10) | yes  | b
 a      | integer               | yes  | a
primary key, btree, for table "public.cwi_test"

DROP INDEX cwi_replaced_pkey;	-- Should fail; a constraint depends on it
ERROR:  cannot drop index cwi_replaced_pkey because constraint cwi_replaced_pkey on table cwi_test requires it
HINT:  You can drop constraint cwi_replaced_pkey on table cwi_test instead.
DROP TABLE cwi_test;
-- ADD CONSTRAINT USING INDEX is forbidden on partitioned tables
CREATE TABLE cwi_test(a int) PARTITION BY hash (a);
create unique index on cwi_test (a);
alter table cwi_test add primary key using index cwi_test_a_idx ;
ERROR:  ALTER TABLE / ADD CONSTRAINT USING INDEX is not supported on partitioned tables
DROP TABLE cwi_test;
--
-- Check handling of indexes on system columns
--
CREATE TABLE syscol_table (a INT);
-- System columns cannot be indexed
CREATE INDEX ON syscolcol_table (ctid);
ERROR:  relation "syscolcol_table" does not exist
-- nor used in expressions
CREATE INDEX ON syscol_table ((ctid >= '(1000,0)'));
ERROR:  index creation on system columns is not supported
-- nor used in predicates
CREATE INDEX ON syscol_table (a) WHERE ctid >= '(1000,0)';
ERROR:  index creation on system columns is not supported
DROP TABLE syscol_table;
--
-- Tests for IS NULL/IS NOT NULL with b-tree indexes
--
SELECT unique1, unique2 INTO onek_with_null FROM onek;
INSERT INTO onek_with_null (unique1,unique2) VALUES (NULL, -1), (NULL, NULL);
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2,unique1);
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = ON;
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2 desc nulls last,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2  nulls first,unique1);
SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL;
 count 
-------
     2
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL;
 count 
-------
  1000
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique2 IS NOT NULL;
 count 
-------
     1
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NOT NULL AND unique1 > 500;
 count 
-------
   499
(1 row)

SELECT count(*) FROM onek_with_null WHERE unique1 IS NULL AND unique1 > 500;
 count 
-------
     0
(1 row)

DROP INDEX onek_nulltest;
-- Check initial-positioning logic too
CREATE UNIQUE INDEX onek_nulltest ON onek_with_null (unique2);
SET enable_seqscan = OFF;
SET enable_indexscan = ON;
SET enable_bitmapscan = OFF;
SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
     147 |       0
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
         |      -1
     147 |       0
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= 0
  ORDER BY unique2 LIMIT 2;
 unique1 | unique2 
---------+---------
     147 |       0
     931 |       1
(2 rows)

SELECT unique1, unique2 FROM onek_with_null
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
         |        
     278 |     999
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 >= -1
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
     278 |     999
       0 |     998
(2 rows)

SELECT unique1, unique2 FROM onek_with_null WHERE unique2 < 999
  ORDER BY unique2 DESC LIMIT 2;
 unique1 | unique2 
---------+---------
       0 |     998
     744 |     997
(2 rows)

RESET enable_seqscan;
RESET enable_indexscan;
RESET enable_bitmapscan;
DROP TABLE onek_with_null;
--
-- Check bitmap index path planning
--
EXPLAIN (COSTS OFF)
SELECT * FROM tenk1
  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
                           QUERY PLAN                            
-----------------------------------------------------------------
 Index Scan using tenk1_thous_tenthous on tenk1
   Index Cond: (thousand = 42)
   Filter: ((tenthous = 1) OR (tenthous = 3) OR (tenthous = 42))
(3 rows)

SELECT * FROM tenk1
  WHERE thousand = 42 AND (tenthous = 1 OR tenthous = 3 OR tenthous = 42);
 unique1 | unique2 | two | four | ten | twenty | hundred | thousand | twothousand | fivethous | tenthous | odd | even | stringu1 | stringu2 | string4 
---------+---------+-----+------+-----+--------+---------+----------+-------------+-----------+----------+-----+------+----------+----------+---------
      42 |    5530 |   0 |    2 |   2 |      2 |      42 |       42 |          42 |        42 |       42 |  84 |   85 | QBAAAA   | SEIAAA   | OOOOxx
(1 row)

EXPLAIN (COSTS OFF)
SELECT count(*) FROM tenk1
  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
                      QUERY PLAN                      
------------------------------------------------------
 Aggregate
   ->  Index Scan using tenk1_hundred on tenk1
         Index Cond: (hundred = 42)
         Filter: ((thousand = 42) OR (thousand = 99))
(4 rows)

SELECT count(*) FROM tenk1
  WHERE hundred = 42 AND (thousand = 42 OR thousand = 99);
 count 
-------
    10
(1 row)

--
-- Check behavior with duplicate index column contents
--
CREATE TABLE dupindexcols AS
  SELECT unique1 as id, stringu2::text as f1 FROM tenk1;
CREATE INDEX dupindexcols_i ON dupindexcols (f1, id, f1 text_pattern_ops);
ANALYZE dupindexcols;
EXPLAIN (COSTS OFF)
  SELECT count(*) FROM dupindexcols
    WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Aggregate
   ->  Index Scan using dupindexcols_i on dupindexcols
         Index Cond: ((f1 >= 'WA'::text) AND (f1 <= 'ZZZ'::text) AND (id < 1000) AND (f1 ~<~ 'YX'::text))
(3 rows)

SELECT count(*) FROM dupindexcols
  WHERE f1 BETWEEN 'WA' AND 'ZZZ' and id < 1000 and f1 ~<~ 'YX';
 count 
-------
    97
(1 row)

--
-- Check ordering of =ANY indexqual results (bug in 9.2.0)
--
vacuum tenk1;		-- ensure we get consistent plans here
explain (costs off)
SELECT unique1 FROM tenk1
WHERE unique1 IN (1,42,7)
ORDER BY unique1;
                      QUERY PLAN                       
-------------------------------------------------------
 Index Scan using tenk1_unique1 on tenk1
   Index Cond: (unique1 = ANY ('{1,42,7}'::integer[]))
(2 rows)

SELECT unique1 FROM tenk1
WHERE unique1 IN (1,42,7)
ORDER BY unique1;
 unique1 
---------
       1
       7
      42
(3 rows)

explain (costs off)
SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
                      QUERY PLAN                       
-------------------------------------------------------
 Index Scan using tenk1_thous_tenthous on tenk1
   Index Cond: (thousand < 2)
   Filter: (tenthous = ANY ('{1001,3000}'::integer[]))
(3 rows)

SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
 thousand | tenthous 
----------+----------
        0 |     3000
        1 |     1001
(2 rows)

SET enable_indexonlyscan = OFF;
explain (costs off)
SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
                      QUERY PLAN                       
-------------------------------------------------------
 Index Scan using tenk1_thous_tenthous on tenk1
   Index Cond: (thousand < 2)
   Filter: (tenthous = ANY ('{1001,3000}'::integer[]))
(3 rows)

SELECT thousand, tenthous FROM tenk1
WHERE thousand < 2 AND tenthous IN (1001,3000)
ORDER BY thousand;
 thousand | tenthous 
----------+----------
        0 |     3000
        1 |     1001
(2 rows)

RESET enable_indexonlyscan;
--
-- Check elimination of constant-NULL subexpressions
--
explain (costs off)
  select * from tenk1 where (thousand, tenthous) in ((1,1001), (null,null));
                      QUERY PLAN                      
------------------------------------------------------
 Index Scan using tenk1_thous_tenthous on tenk1
   Index Cond: ((thousand = 1) AND (tenthous = 1001))
(2 rows)

--
-- Check matching of boolean index columns to WHERE conditions and sort keys
--
create temp table boolindex (b bool, i int, unique(b, i), junk float);
explain (costs off)
  select * from boolindex order by b, i limit 10;
            QUERY PLAN             
-----------------------------------
 Limit
   ->  Sort
         Sort Key: b, i
         ->  Seq Scan on boolindex
(4 rows)

explain (costs off)
  select * from boolindex where b order by i limit 10;
            QUERY PLAN             
-----------------------------------
 Limit
   ->  Sort
         Sort Key: i
         ->  Seq Scan on boolindex
               Filter: b
(5 rows)

explain (costs off)
  select * from boolindex where b = true order by i desc limit 10;
            QUERY PLAN             
-----------------------------------
 Limit
   ->  Sort
         Sort Key: i DESC
         ->  Seq Scan on boolindex
               Filter: b
(5 rows)

explain (costs off)
  select * from boolindex where not b order by i limit 10;
            QUERY PLAN             
-----------------------------------
 Limit
   ->  Sort
         Sort Key: i
         ->  Seq Scan on boolindex
               Filter: (NOT b)
(5 rows)

explain (costs off)
  select * from boolindex where b is true order by i desc limit 10;
            QUERY PLAN             
-----------------------------------
 Limit
   ->  Sort
         Sort Key: i DESC
         ->  Seq Scan on boolindex
               Filter: (b IS TRUE)
(5 rows)

explain (costs off)
  select * from boolindex where b is false order by i desc limit 10;
             QUERY PLAN             
------------------------------------
 Limit
   ->  Sort
         Sort Key: i DESC
         ->  Seq Scan on boolindex
               Filter: (b IS FALSE)
(5 rows)

--
-- REINDEX (VERBOSE)
--
CREATE TABLE reindex_verbose(id integer primary key);
\set VERBOSITY terse \\ -- suppress machine-dependent details
REINDEX (VERBOSE) TABLE reindex_verbose;
INFO:  index "reindex_verbose_pkey" was reindexed
\set VERBOSITY default
DROP TABLE reindex_verbose;
--
-- REINDEX CONCURRENTLY
--
CREATE TABLE concur_reindex_tab (c1 int);
-- REINDEX
REINDEX TABLE concur_reindex_tab; -- notice
NOTICE:  table "concur_reindex_tab" has no indexes to reindex
REINDEX TABLE CONCURRENTLY concur_reindex_tab; -- notice
NOTICE:  table "concur_reindex_tab" has no indexes to reindex
ALTER TABLE concur_reindex_tab ADD COLUMN c2 text; -- add toast index
-- Normal index with integer column
CREATE UNIQUE INDEX concur_reindex_ind1 ON concur_reindex_tab(c1);
-- Normal index with text column
CREATE INDEX concur_reindex_ind2 ON concur_reindex_tab(c2);
-- UNIQUE index with expression
CREATE UNIQUE INDEX concur_reindex_ind3 ON concur_reindex_tab(abs(c1));
-- Duplicate column names
CREATE INDEX concur_reindex_ind4 ON concur_reindex_tab(c1, c1, c2);
-- Create table for check on foreign key dependence switch with indexes swapped
ALTER TABLE concur_reindex_tab ADD PRIMARY KEY USING INDEX concur_reindex_ind1;
CREATE TABLE concur_reindex_tab2 (c1 int REFERENCES concur_reindex_tab);
INSERT INTO concur_reindex_tab VALUES  (1, 'a');
INSERT INTO concur_reindex_tab VALUES  (2, 'a');
-- Reindex concurrently of exclusion constraint currently not supported
CREATE TABLE concur_reindex_tab3 (c1 int, c2 int4range);
INSERT INTO concur_reindex_tab3 VALUES  (3, '[1,2]');
INSERT INTO concur_reindex_tab3 VALUES  (4, '[2,4]');
-- Check materialized views
CREATE MATERIALIZED VIEW concur_reindex_matview AS SELECT * FROM concur_reindex_tab;
-- Dependency lookup before and after the follow-up REINDEX commands.
-- These should remain consistent.
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_tab'::regclass,
            'concur_reindex_ind1'::regclass,
	    'concur_reindex_ind2'::regclass,
	    'concur_reindex_ind3'::regclass,
	    'concur_reindex_ind4'::regclass,
	    'concur_reindex_matview'::regclass)
  ORDER BY 1, 2;
                   obj                    |                           objref                           | deptype 
------------------------------------------+------------------------------------------------------------+---------
 index concur_reindex_ind1                | constraint concur_reindex_ind1 on table concur_reindex_tab | i
 index concur_reindex_ind2                | column c2 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | table concur_reindex_tab                                   | a
 index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind4                | column c2 of table concur_reindex_tab                      | a
 materialized view concur_reindex_matview | schema public                                              | n
 table concur_reindex_tab                 | schema public                                              | n
(9 rows)

REINDEX INDEX CONCURRENTLY concur_reindex_ind1;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
REINDEX TABLE CONCURRENTLY concur_reindex_matview;
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_tab'::regclass,
            'concur_reindex_ind1'::regclass,
	    'concur_reindex_ind2'::regclass,
	    'concur_reindex_ind3'::regclass,
	    'concur_reindex_ind4'::regclass,
	    'concur_reindex_matview'::regclass)
  ORDER BY 1, 2;
                   obj                    |                           objref                           | deptype 
------------------------------------------+------------------------------------------------------------+---------
 index concur_reindex_ind1                | constraint concur_reindex_ind1 on table concur_reindex_tab | i
 index concur_reindex_ind2                | column c2 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind3                | table concur_reindex_tab                                   | a
 index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind4                | column c1 of table concur_reindex_tab                      | a
 index concur_reindex_ind4                | column c2 of table concur_reindex_tab                      | a
 materialized view concur_reindex_matview | schema public                                              | n
 table concur_reindex_tab                 | schema public                                              | n
(9 rows)

-- Check that comments are preserved
CREATE TABLE testcomment (i int);
CREATE INDEX testcomment_idx1 ON testcomment (i);
COMMENT ON INDEX testcomment_idx1 IS 'test comment';
SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
 obj_description 
-----------------
 test comment
(1 row)

REINDEX TABLE testcomment;
SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
 obj_description 
-----------------
 test comment
(1 row)

REINDEX TABLE CONCURRENTLY testcomment ;
SELECT obj_description('testcomment_idx1'::regclass, 'pg_class');
 obj_description 
-----------------
 test comment
(1 row)

DROP TABLE testcomment;
-- Check that indisclustered updates are preserved
CREATE TABLE concur_clustered(i int);
CREATE INDEX concur_clustered_i_idx ON concur_clustered(i);
ALTER TABLE concur_clustered CLUSTER ON concur_clustered_i_idx;
REINDEX TABLE CONCURRENTLY concur_clustered;
SELECT indexrelid::regclass, indisclustered FROM pg_index
  WHERE indrelid = 'concur_clustered'::regclass;
       indexrelid       | indisclustered 
------------------------+----------------
 concur_clustered_i_idx | t
(1 row)

DROP TABLE concur_clustered;
-- Check that indisreplident updates are preserved.
CREATE TABLE concur_replident(i int NOT NULL);
CREATE UNIQUE INDEX concur_replident_i_idx ON concur_replident(i);
ALTER TABLE concur_replident REPLICA IDENTITY
  USING INDEX concur_replident_i_idx;
SELECT indexrelid::regclass, indisreplident FROM pg_index
  WHERE indrelid = 'concur_replident'::regclass;
       indexrelid       | indisreplident 
------------------------+----------------
 concur_replident_i_idx | t
(1 row)

REINDEX TABLE CONCURRENTLY concur_replident;
SELECT indexrelid::regclass, indisreplident FROM pg_index
  WHERE indrelid = 'concur_replident'::regclass;
       indexrelid       | indisreplident 
------------------------+----------------
 concur_replident_i_idx | t
(1 row)

DROP TABLE concur_replident;
-- Partitions
-- Create some partitioned tables
CREATE TABLE concur_reindex_part (c1 int, c2 int) PARTITION BY RANGE (c1);
CREATE TABLE concur_reindex_part_0 PARTITION OF concur_reindex_part
  FOR VALUES FROM (0) TO (10) PARTITION BY list (c2);
CREATE TABLE concur_reindex_part_0_1 PARTITION OF concur_reindex_part_0
  FOR VALUES IN (1);
CREATE TABLE concur_reindex_part_0_2 PARTITION OF concur_reindex_part_0
  FOR VALUES IN (2);
-- This partitioned table will have no partitions.
CREATE TABLE concur_reindex_part_10 PARTITION OF concur_reindex_part
  FOR VALUES FROM (10) TO (20) PARTITION BY list (c2);
-- Create some partitioned indexes
CREATE INDEX concur_reindex_part_index ON ONLY concur_reindex_part (c1);
CREATE INDEX concur_reindex_part_index_0 ON ONLY concur_reindex_part_0 (c1);
ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_0;
-- This partitioned index will have no partitions.
CREATE INDEX concur_reindex_part_index_10 ON ONLY concur_reindex_part_10 (c1);
ALTER INDEX concur_reindex_part_index ATTACH PARTITION concur_reindex_part_index_10;
CREATE INDEX concur_reindex_part_index_0_1 ON ONLY concur_reindex_part_0_1 (c1);
ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_1;
CREATE INDEX concur_reindex_part_index_0_2 ON ONLY concur_reindex_part_0_2 (c1);
ALTER INDEX concur_reindex_part_index_0 ATTACH PARTITION concur_reindex_part_index_0_2;
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

-- REINDEX fails for partitioned indexes
REINDEX INDEX concur_reindex_part_index_10;
ERROR:  REINDEX is not yet implemented for partitioned indexes
REINDEX INDEX CONCURRENTLY concur_reindex_part_index_10;
ERROR:  REINDEX is not yet implemented for partitioned indexes
-- REINDEX is a no-op for partitioned tables
REINDEX TABLE concur_reindex_part_10;
WARNING:  REINDEX of partitioned tables is not yet implemented, skipping "concur_reindex_part_10"
NOTICE:  table "concur_reindex_part_10" has no indexes to reindex
REINDEX TABLE CONCURRENTLY concur_reindex_part_10;
WARNING:  REINDEX of partitioned tables is not yet implemented, skipping "concur_reindex_part_10"
NOTICE:  table "concur_reindex_part_10" has no indexes to reindex
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

-- REINDEX should preserve dependencies of partition tree.
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_part'::regclass,
            'concur_reindex_part_0'::regclass,
            'concur_reindex_part_0_1'::regclass,
            'concur_reindex_part_0_2'::regclass,
            'concur_reindex_part_index'::regclass,
            'concur_reindex_part_index_0'::regclass,
            'concur_reindex_part_index_0_1'::regclass,
            'concur_reindex_part_index_0_2'::regclass)
  ORDER BY 1, 2;
                   obj                    |                   objref                   | deptype 
------------------------------------------+--------------------------------------------+---------
 column c1 of table concur_reindex_part   | table concur_reindex_part                  | i
 column c2 of table concur_reindex_part_0 | table concur_reindex_part_0                | i
 index concur_reindex_part_index          | column c1 of table concur_reindex_part     | a
 index concur_reindex_part_index_0        | column c1 of table concur_reindex_part_0   | a
 index concur_reindex_part_index_0        | index concur_reindex_part_index            | P
 index concur_reindex_part_index_0        | table concur_reindex_part_0                | S
 index concur_reindex_part_index_0_1      | column c1 of table concur_reindex_part_0_1 | a
 index concur_reindex_part_index_0_1      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_1      | table concur_reindex_part_0_1              | S
 index concur_reindex_part_index_0_2      | column c1 of table concur_reindex_part_0_2 | a
 index concur_reindex_part_index_0_2      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_2      | table concur_reindex_part_0_2              | S
 table concur_reindex_part                | schema public                              | n
 table concur_reindex_part_0              | schema public                              | n
 table concur_reindex_part_0              | table concur_reindex_part                  | a
 table concur_reindex_part_0_1            | schema public                              | n
 table concur_reindex_part_0_1            | table concur_reindex_part_0                | a
 table concur_reindex_part_0_2            | schema public                              | n
 table concur_reindex_part_0_2            | table concur_reindex_part_0                | a
(19 rows)

REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_1;
REINDEX INDEX CONCURRENTLY concur_reindex_part_index_0_2;
SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

REINDEX TABLE CONCURRENTLY concur_reindex_part_0_1;
REINDEX TABLE CONCURRENTLY concur_reindex_part_0_2;
SELECT pg_describe_object(classid, objid, objsubid) as obj,
       pg_describe_object(refclassid,refobjid,refobjsubid) as objref,
       deptype
FROM pg_depend
WHERE classid = 'pg_class'::regclass AND
  objid in ('concur_reindex_part'::regclass,
            'concur_reindex_part_0'::regclass,
            'concur_reindex_part_0_1'::regclass,
            'concur_reindex_part_0_2'::regclass,
            'concur_reindex_part_index'::regclass,
            'concur_reindex_part_index_0'::regclass,
            'concur_reindex_part_index_0_1'::regclass,
            'concur_reindex_part_index_0_2'::regclass)
  ORDER BY 1, 2;
                   obj                    |                   objref                   | deptype 
------------------------------------------+--------------------------------------------+---------
 column c1 of table concur_reindex_part   | table concur_reindex_part                  | i
 column c2 of table concur_reindex_part_0 | table concur_reindex_part_0                | i
 index concur_reindex_part_index          | column c1 of table concur_reindex_part     | a
 index concur_reindex_part_index_0        | column c1 of table concur_reindex_part_0   | a
 index concur_reindex_part_index_0        | index concur_reindex_part_index            | P
 index concur_reindex_part_index_0        | table concur_reindex_part_0                | S
 index concur_reindex_part_index_0_1      | column c1 of table concur_reindex_part_0_1 | a
 index concur_reindex_part_index_0_1      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_1      | table concur_reindex_part_0_1              | S
 index concur_reindex_part_index_0_2      | column c1 of table concur_reindex_part_0_2 | a
 index concur_reindex_part_index_0_2      | index concur_reindex_part_index_0          | P
 index concur_reindex_part_index_0_2      | table concur_reindex_part_0_2              | S
 table concur_reindex_part                | schema public                              | n
 table concur_reindex_part_0              | schema public                              | n
 table concur_reindex_part_0              | table concur_reindex_part                  | a
 table concur_reindex_part_0_1            | schema public                              | n
 table concur_reindex_part_0_1            | table concur_reindex_part_0                | a
 table concur_reindex_part_0_2            | schema public                              | n
 table concur_reindex_part_0_2            | table concur_reindex_part_0                | a
(19 rows)

SELECT relid, parentrelid, level FROM pg_partition_tree('concur_reindex_part_index')
  ORDER BY relid, level;
             relid             |         parentrelid         | level 
-------------------------------+-----------------------------+-------
 concur_reindex_part_index     |                             |     0
 concur_reindex_part_index_0   | concur_reindex_part_index   |     1
 concur_reindex_part_index_10  | concur_reindex_part_index   |     1
 concur_reindex_part_index_0_1 | concur_reindex_part_index_0 |     2
 concur_reindex_part_index_0_2 | concur_reindex_part_index_0 |     2
(5 rows)

DROP TABLE concur_reindex_part;
-- Check errors
-- Cannot run inside a transaction block
BEGIN;
REINDEX TABLE CONCURRENTLY concur_reindex_tab;
ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- REINDEX TABLE CONCURRENTLY pg_class; -- no catalog relation
-- REINDEX INDEX CONCURRENTLY pg_class_oid_index; -- no catalog index
-- -- These are the toast table and index of pg_authid.
-- REINDEX TABLE CONCURRENTLY pg_toast.pg_toast_1260; -- no catalog toast table
-- REINDEX INDEX CONCURRENTLY pg_toast.pg_toast_1260_index; -- no catalog toast index
-- REINDEX SYSTEM CONCURRENTLY postgres; -- not allowed for SYSTEM
-- -- Warns about catalog relations
-- REINDEX SCHEMA CONCURRENTLY pg_catalog;
-- Check the relation status, there should not be invalid indexes
\d concur_reindex_tab
         Table "public.concur_reindex_tab"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           | not null | 
 c2     | text    |           |          | 
Indexes:
    "concur_reindex_ind1" PRIMARY KEY, btree (c1)
    "concur_reindex_ind3" UNIQUE, btree (abs(c1))
    "concur_reindex_ind2" btree (c2)
    "concur_reindex_ind4" btree (c1, c1, c2)
Referenced by:
    TABLE "concur_reindex_tab2" CONSTRAINT "concur_reindex_tab2_c1_fkey" FOREIGN KEY (c1) REFERENCES concur_reindex_tab(c1)

DROP MATERIALIZED VIEW concur_reindex_matview;
DROP TABLE concur_reindex_tab, concur_reindex_tab2, concur_reindex_tab3;
-- Check handling of invalid indexes
CREATE TABLE concur_reindex_tab4 (c1 int);
INSERT INTO concur_reindex_tab4 VALUES (1), (1), (2);
-- This trick creates an invalid index.
CREATE UNIQUE INDEX CONCURRENTLY concur_reindex_ind5 ON concur_reindex_tab4 (c1);
ERROR:  could not create unique index "concur_reindex_ind5"
DETAIL:  Key (c1)=(1) is duplicated.
-- Reindexing concurrently this index fails with the same failure.
-- The extra index created is itself invalid, and can be dropped.
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
ERROR:  relation "concur_reindex_ind5" does not exist
\d concur_reindex_tab4
        Table "public.concur_reindex_tab4"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           |          | 

DROP INDEX concur_reindex_ind5_ccnew;
ERROR:  index "concur_reindex_ind5_ccnew" does not exist
-- This makes the previous failure go away, so the index can become valid.
DELETE FROM concur_reindex_tab4 WHERE c1 = 1;
-- The invalid index is not processed when running REINDEX TABLE.
REINDEX TABLE CONCURRENTLY concur_reindex_tab4;
NOTICE:  table "concur_reindex_tab4" has no indexes to reindex
\d concur_reindex_tab4
        Table "public.concur_reindex_tab4"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           |          | 

-- But it is fixed with REINDEX INDEX.
REINDEX INDEX CONCURRENTLY concur_reindex_ind5;
ERROR:  relation "concur_reindex_ind5" does not exist
\d concur_reindex_tab4
        Table "public.concur_reindex_tab4"
 Column |  Type   | Collation | Nullable | Default 
--------+---------+-----------+----------+---------
 c1     | integer |           |          | 

DROP TABLE concur_reindex_tab4;
-- Check handling of indexes with expressions and predicates.  The
-- definitions of the rebuilt indexes should match the original
-- definitions.
CREATE TABLE concur_exprs_tab (c1 int , c2 boolean);
INSERT INTO concur_exprs_tab (c1, c2) VALUES (1369652450, FALSE),
  (414515746, TRUE),
  (897778963, FALSE);
CREATE UNIQUE INDEX concur_exprs_index_expr
  ON concur_exprs_tab ((c1::text COLLATE "C"));
CREATE UNIQUE INDEX concur_exprs_index_pred ON concur_exprs_tab (c1)
  WHERE (c1::text > 500000000::text COLLATE "C");
CREATE UNIQUE INDEX concur_exprs_index_pred_2
  ON concur_exprs_tab ((1 / c1))
  WHERE ('-H') >= (c2::TEXT) COLLATE "C";
ANALYZE concur_exprs_tab;
SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
  'concur_exprs_index_expr'::regclass,
  'concur_exprs_index_pred'::regclass,
  'concur_exprs_index_pred_2'::regclass)
  GROUP BY starelid ORDER BY starelid::regclass::text;
        starelid         | count 
-------------------------+-------
 concur_exprs_index_expr |     1
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
                                                pg_get_indexdef                                                
---------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
                                                               pg_get_indexdef                                                                
----------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
                                                                 pg_get_indexdef                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= ((c2)::text COLLATE "C"))
(1 row)

REINDEX TABLE CONCURRENTLY concur_exprs_tab;
SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
                                                pg_get_indexdef                                                
---------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
                                                               pg_get_indexdef                                                                
----------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
                                                                 pg_get_indexdef                                                                  
--------------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= ((c2)::text COLLATE "C"))
(1 row)

-- ALTER TABLE recreates the indexes, which should keep their collations.
ALTER TABLE concur_exprs_tab ALTER c2 TYPE TEXT;
SELECT pg_get_indexdef('concur_exprs_index_expr'::regclass);
                                                pg_get_indexdef                                                
---------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_expr ON public.concur_exprs_tab USING btree (((c1)::text) COLLATE "C")
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred'::regclass);
                                                               pg_get_indexdef                                                                
----------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred ON public.concur_exprs_tab USING btree (c1) WHERE ((c1)::text > ((500000000)::text COLLATE "C"))
(1 row)

SELECT pg_get_indexdef('concur_exprs_index_pred_2'::regclass);
                                                             pg_get_indexdef                                                              
------------------------------------------------------------------------------------------------------------------------------------------
 CREATE UNIQUE INDEX concur_exprs_index_pred_2 ON public.concur_exprs_tab USING btree (((1 / c1))) WHERE ('-H'::text >= (c2 COLLATE "C"))
(1 row)

-- Statistics should remain intact.
SELECT starelid::regclass, count(*) FROM pg_statistic WHERE starelid IN (
  'concur_exprs_index_expr'::regclass,
  'concur_exprs_index_pred'::regclass,
  'concur_exprs_index_pred_2'::regclass)
  GROUP BY starelid ORDER BY starelid::regclass::text;
        starelid         | count 
-------------------------+-------
 concur_exprs_index_expr |     1
(1 row)

DROP TABLE concur_exprs_tab;
-- Temporary tables and on-commit actions, where CONCURRENTLY is ignored.
-- ON COMMIT PRESERVE ROWS, the default.
CREATE TEMP TABLE concur_temp_tab_1 (c1 int, c2 text)
  ON COMMIT PRESERVE ROWS;
INSERT INTO concur_temp_tab_1 VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX concur_temp_ind_1 ON concur_temp_tab_1(c2);
REINDEX TABLE CONCURRENTLY concur_temp_tab_1;
REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
-- Still fails in transaction blocks
BEGIN;
REINDEX INDEX CONCURRENTLY concur_temp_ind_1;
ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- ON COMMIT DELETE ROWS
CREATE TEMP TABLE concur_temp_tab_2 (c1 int, c2 text)
  ON COMMIT DELETE ROWS;
CREATE INDEX concur_temp_ind_2 ON concur_temp_tab_2(c2);
REINDEX TABLE CONCURRENTLY concur_temp_tab_2;
REINDEX INDEX CONCURRENTLY concur_temp_ind_2;
-- ON COMMIT DROP
BEGIN;
CREATE TEMP TABLE concur_temp_tab_3 (c1 int, c2 text)
  ON COMMIT PRESERVE ROWS;
INSERT INTO concur_temp_tab_3 VALUES (1, 'foo'), (2, 'bar');
CREATE INDEX concur_temp_ind_3 ON concur_temp_tab_3(c2);
-- Fails when running in a transaction
REINDEX INDEX CONCURRENTLY concur_temp_ind_3;
ERROR:  REINDEX CONCURRENTLY cannot run inside a transaction block
COMMIT;
-- REINDEX SCHEMA processes all temporary relations
CREATE TABLE reindex_temp_before AS
SELECT oid, relname, relfilenode, relkind, reltoastrelid
  FROM pg_class
  WHERE relname IN ('concur_temp_ind_1', 'concur_temp_ind_2');
SELECT pg_my_temp_schema()::regnamespace as temp_schema_name \gset
REINDEX SCHEMA CONCURRENTLY :temp_schema_name;
SELECT  b.relname,
        b.relkind,
        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
        ELSE 'relfilenode has changed' END
  FROM reindex_temp_before b JOIN pg_class a ON b.oid = a.oid
  ORDER BY 1;
      relname      | relkind |          case           
-------------------+---------+-------------------------
 concur_temp_ind_1 | i       | relfilenode has changed
 concur_temp_ind_2 | i       | relfilenode has changed
(2 rows)

DROP TABLE concur_temp_tab_1, concur_temp_tab_2, reindex_temp_before;
--
-- REINDEX SCHEMA
--
REINDEX SCHEMA schema_to_reindex; -- failure, schema does not exist
ERROR:  schema "schema_to_reindex" does not exist
CREATE SCHEMA schema_to_reindex;
SET search_path = 'schema_to_reindex';
CREATE TABLE table1(col1 SERIAL PRIMARY KEY);
INSERT INTO table1 SELECT generate_series(1,400);
CREATE TABLE table2(col1 SERIAL PRIMARY KEY, col2 TEXT NOT NULL);
INSERT INTO table2 SELECT generate_series(1,400), 'abc';
CREATE INDEX ON table2(col2);
CREATE MATERIALIZED VIEW matview AS SELECT col1 FROM table2;
CREATE INDEX ON matview(col1);
CREATE VIEW view AS SELECT col2 FROM table2;
CREATE TABLE reindex_before AS
SELECT oid, relname, relfilenode, relkind, reltoastrelid
	FROM pg_class
	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
INSERT INTO reindex_before
SELECT oid, 'pg_toast_TABLE', relfilenode, relkind, reltoastrelid
FROM pg_class WHERE oid IN
	(SELECT reltoastrelid FROM reindex_before WHERE reltoastrelid > 0);
INSERT INTO reindex_before
SELECT oid, 'pg_toast_TABLE_index', relfilenode, relkind, reltoastrelid
FROM pg_class where oid in
	(select indexrelid from pg_index where indrelid in
		(select reltoastrelid from reindex_before where reltoastrelid > 0));
REINDEX SCHEMA schema_to_reindex;
CREATE TABLE reindex_after AS SELECT oid, relname, relfilenode, relkind
	FROM pg_class
	where relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'schema_to_reindex');
SELECT  b.relname,
        b.relkind,
        CASE WHEN a.relfilenode = b.relfilenode THEN 'relfilenode is unchanged'
        ELSE 'relfilenode has changed' END
  FROM reindex_before b JOIN pg_class a ON b.oid = a.oid
  ORDER BY 1;
       relname        | relkind |           case           
----------------------+---------+--------------------------
 matview              | m       | relfilenode is unchanged
 matview_col1_idx     | i       | relfilenode has changed
 pg_toast_TABLE       | t       | relfilenode is unchanged
 pg_toast_TABLE_index | i       | relfilenode has changed
 table1               | r       | relfilenode is unchanged
 table1_col1_seq      | S       | relfilenode is unchanged
 table1_pkey          | i       | relfilenode has changed
 table2               | r       | relfilenode is unchanged
 table2_col1_seq      | S       | relfilenode is unchanged
 table2_col2_idx      | i       | relfilenode has changed
 table2_pkey          | i       | relfilenode has changed
 view                 | v       | relfilenode is unchanged
(12 rows)

REINDEX SCHEMA schema_to_reindex;
BEGIN;
REINDEX SCHEMA schema_to_reindex; -- failure, cannot run in a transaction
ERROR:  REINDEX SCHEMA cannot run inside a transaction block
END;
-- concurrently
REINDEX SCHEMA CONCURRENTLY schema_to_reindex;
-- Failure for unauthorized user
CREATE ROLE regress_reindexuser NOLOGIN;
SET SESSION ROLE regress_reindexuser;
REINDEX SCHEMA schema_to_reindex;
ERROR:  must be owner of schema schema_to_reindex
-- Permission failures with toast tables and indexes (pg_authid here)
RESET ROLE;
GRANT USAGE ON SCHEMA pg_toast TO regress_reindexuser;
SET SESSION ROLE regress_reindexuser;
REINDEX TABLE pg_toast.pg_toast_1260;
ERROR:  must be owner of table pg_toast_1260
REINDEX INDEX pg_toast.pg_toast_1260_index;
ERROR:  must be owner of index pg_toast_1260_index
-- Clean up
RESET ROLE;
REVOKE USAGE ON SCHEMA pg_toast FROM regress_reindexuser;
DROP ROLE regress_reindexuser;
DROP SCHEMA schema_to_reindex CASCADE;
NOTICE:  drop cascades to 6 other objects
DETAIL:  drop cascades to table table1
drop cascades to table table2
drop cascades to materialized view matview
drop cascades to view view
drop cascades to table reindex_before
drop cascades to table reindex_after
